import bpy
from bpy.props import StringProperty, IntProperty, EnumProperty, BoolProperty
from bpy.types import Operator, Panel, PropertyGroup
import csv, json, os, re
from mathutils import Vector
from bisect import bisect_left

HANDLER_TAG = "_csv_vertex_anim_handler"

# ---------- Utilities ----------

def detect_delimiter(sample_path):
    # Try to sniff; fall back to tab if header matches the sample
    try:
        with open(sample_path, "r", newline="") as f:
            head = f.read(2048)
        dialect = csv.Sniffer().sniff(head, delimiters=",\t; ")
        return dialect.delimiter
    except Exception:
        # Heuristic: if header contains tabs or 'Time [msec]\tx [m]' pattern, use '\t'
        if "\t" in head or re.search(r"Time\s*\[msec\]\s*\tx\s*\[m\]", head):
            return "\t"
        return ","  # default

def load_csv(path, delimiter="auto"):
    if delimiter == "auto":
        delimiter = detect_delimiter(path)
    rows = []
    with open(path, "r", newline="") as f:
        reader = csv.DictReader(f, delimiter=delimiter)
        # Normalize expected headers
        colmap = {k.strip(): k for k in reader.fieldnames}
        req = ["Time [msec]", "x [m]", "y [m]", "z [m]", "Red", "Green", "Blue"]
        for r in reader:
            row = {
                "t_ms": float(r[colmap["Time [msec]"]]),
                "x": float(r[colmap["x [m]"]]),
                "y": float(r[colmap["y [m]"]]),
                "z": float(r[colmap["z [m]"]]),
                "r": float(r[colmap["Red"]]),
                "g": float(r[colmap["Green"]]),
                "b": float(r[colmap["Blue"]]),
            }
            rows.append(row)
    # Ensure sorted by time
    rows.sort(key=lambda d: d["t_ms"])
    return rows

def ms_to_frame(ms, fps):
    return (ms / 1000.0) * fps

def build_tracks_from_folder(folder, delimiter="auto"):
    files = []
    for name in os.listdir(folder):
        low = name.lower()
        if low.endswith(".csv") or low.endswith(".tsv"):
            files.append(os.path.join(folder, name))
    files.sort()
    tracks = []
    for p in files:
        data = load_csv(p, delimiter=delimiter)
        if not data:
            continue
        tracks.append({"name": os.path.splitext(os.path.basename(p))[0], "data": data})
    return tracks

def ensure_single_mesh(name="CSV_Tracks", count=1, first_positions=None):
    # Create a mesh object with 'count' vertices (no edges/faces)
    mesh = bpy.data.meshes.new(name + "_mesh")
    obj = bpy.data.objects.new(name, mesh)
    bpy.context.scene.collection.objects.link(obj)
    # Build vertex list
    if first_positions and len(first_positions) == count:
        verts = [tuple(first_positions[i]) for i in range(count)]
    else:
        verts = [(0.0, 0.0, 0.0) for _ in range(count)]
    mesh.from_pydata(verts, [], [])
    mesh.update()
    return obj

def unregister_handler():
    sc = bpy.context.scene
    # Remove existing handler if exists
    if getattr(sc, HANDLER_TAG, None):
        tag = sc.get(HANDLER_TAG)
        # Clear all matching handlers
        for h in list(bpy.app.handlers.frame_change_post):
            if getattr(h, "__name__", "") == tag:
                bpy.app.handlers.frame_change_post.remove(h)
        del sc[HANDLER_TAG]

def register_handler(fn):
    unregister_handler()
    bpy.app.handlers.frame_change_post.append(fn)
    bpy.context.scene[HANDLER_TAG] = fn.__name__

# ---------- Core: Frame Update ----------

def make_frame_handler(obj):
    """
    Returns a frame_change_post handler function that:
      - Reads JSON tracks from obj['csv_tracks_json']
      - Moves each vertex to interpolated position at current frame
    """
    # Capture name to resolve object each call (avoid stale refs on file reload)
    obj_name = obj.name

    def handler(scene):
        ob = scene.objects.get(obj_name)
        if not ob or "csv_tracks_json" not in ob:
            return
        if not ob.data or ob.data.name not in bpy.data.meshes:
            return

        mesh = ob.data
        try:
            payload = json.loads(ob["csv_tracks_json"])
        except Exception:
            return

        fps = float(payload.get("fps", 24.0))
        start_frame = int(payload.get("start_frame", 0))
        tracks = payload.get("tracks", [])
        if not tracks:
            return

        # Build per-track time list cache (optional)
        frame = scene.frame_current
        t_ms = ((frame - start_frame) / fps) * 1000.0

        mesh_vertices = mesh.vertices
        # Safety
        n = min(len(tracks), len(mesh_vertices))

        for i in range(n):
            seq = tracks[i]["data"]  # list of dicts
            # binary search on time
            times = payload["time_index"][i]
            idx = bisect_left(times, t_ms)
            if idx <= 0:
                p = seq[0]
                ob_co = (p["x"], p["y"], p["z"])
            elif idx >= len(seq):
                p = seq[-1]
                ob_co = (p["x"], p["y"], p["z"])
            else:
                a = seq[idx - 1]
                b = seq[idx]
                # Linear interpolation
                t0, t1 = a["t_ms"], b["t_ms"]
                k = 0.0 if t1 == t0 else (t_ms - t0) / (t1 - t0)
                ob_co = (
                    a["x"] + (b["x"] - a["x"]) * k,
                    a["y"] + (b["y"] - a["y"]) * k,
                    a["z"] + (b["z"] - a["z"]) * k,
                )
            mesh_vertices[i].co = Vector(ob_co)

        mesh.update()

    # Give a stable name for clean unregistration
    handler.__name__ = "csv_vertex_anim_handler_runtime"
    return handler

# ---------- Properties / UI ----------

class CSVVA_Props(PropertyGroup):
    folder: StringProperty(
        name="CSVフォルダ",
        description="Time[msec], x[m], y[m], z[m], Red, Green, Blue を含むCSV/TSVのフォルダ",
        subtype="DIR_PATH",
    )
    fps: IntProperty(
        name="FPS",
        default=24,
        min=1,
        max=480,
    )
    start_frame: IntProperty(
        name="Start Frame",
        default=0,
    )
    delimiter: EnumProperty(
        name="区切り",
        items=[
            ("auto", "自動", "自動判別"),
            ("\t", "タブ", "タブ区切り"),
            (",", "カンマ", "カンマ区切り"),
            (";", "セミコロン", "セミコロン"),
        ],
        default="auto",
    )
    normalize_rgb: BoolProperty(
        name="RGBを0-1正規化",
        default=False,
        description="キーに打つ色値を0-255のままではなく0-1へ正規化して保存",
    )

class CSVVA_OT_Import(Operator):
    bl_idname = "csvva.import_setup"
    bl_label = "インポート＆セットアップ"
    bl_options = {"REGISTER", "UNDO"}

    def execute(self, context):
        prefs = context.scene.csvva_props
        start_frame = int(prefs.start_frame)
        folder = bpy.path.abspath(prefs.folder)
        if not os.path.isdir(folder):
            self.report({"ERROR"}, "CSVフォルダが不正です")
            return {"CANCELLED"}

        folder_name = os.path.basename(os.path.normpath(folder))
        tracks = build_tracks_from_folder(folder, delimiter=prefs.delimiter)
        if not tracks:
            self.report({"ERROR"}, "フォルダ内にCSV/TSVが見つかりません")
            return {"CANCELLED"}

        # Determine total duration in frames
        max_t_ms = max(tr["data"][-1]["t_ms"] for tr in tracks if tr["data"])
        duration = int(ms_to_frame(max_t_ms, prefs.fps))

        # Build initial positions array
        first_positions = []
        for tr in tracks:
            d0 = tr["data"][0]
            first_positions.append((d0["x"], d0["y"], d0["z"]))

        # Create single mesh with N vertices, named after the folder
        obj = ensure_single_mesh(name=folder_name, count=len(tracks), first_positions=first_positions)

        # Create a vertex group containing all vertices for formations
        vg = obj.vertex_groups.new(name="Drones")
        vg.add(range(len(obj.data.vertices)), 1.0, 'REPLACE')

        if hasattr(obj, "skybrush"):
            obj.skybrush.formation_vertex_group = "Drones"

        # Create a formation and add a storyboard entry
        bpy.ops.object.select_all(action='DESELECT')
        obj.select_set(True)
        context.view_layer.objects.active = obj
        bpy.ops.skybrush.create_formation(name=obj.name, contents='SELECTED_OBJECTS')
        try:
            bpy.ops.skybrush.append_formation_to_storyboard()
            storyboard = context.scene.skybrush.storyboard
            entry = storyboard.entries[-1]
            entry.name = folder_name
            entry.frame_start = start_frame
            entry.duration = duration
        except Exception:
            pass

        # Build payload for handler: store compact JSON on the object
        payload = {
            "fps": prefs.fps,
            "start_frame": start_frame,
            "tracks": tracks,  # this is large; OK for moderate sizes
            "time_index": [[row["t_ms"] for row in tr["data"]] for tr in tracks],
        }
        obj["csv_tracks_json"] = json.dumps(payload)

        # Color keyframes: either store on object properties or directly on drone materials
        normalize = prefs.normalize_rgb
        fps = float(prefs.fps)

        for i, tr in enumerate(tracks):
            # Find corresponding drone material input (Base Color)
            base_socket = None
            drones_col = bpy.data.collections.get("Drones")
            if drones_col:
                drone = drones_col.objects.get(tr["name"])
                if drone and drone.active_material and drone.active_material.node_tree:
                    for node in drone.active_material.node_tree.nodes:
                        if node.inputs and node.inputs[0].type == 'RGBA':
                            base_socket = node.inputs[0]
                            break

            # If no material socket is found, fall back to custom properties
            if not base_socket:
                # Ensure action to hold FCurves (so keys are visible in DopeSheet)
                if not obj.animation_data:
                    obj.animation_data_create()
                if not obj.animation_data.action:
                    obj.animation_data.action = bpy.data.actions.new(name="CSV_ColorKeys")
                for ch in ("R", "G", "B"):
                    key = f'vc[{i}]_{ch}'
                    if key not in obj:
                        obj[key] = 0.0

            for row in tr["data"]:
                frame = start_frame + ms_to_frame(row["t_ms"], fps)
                raw_r, raw_g, raw_b = row["r"], row["g"], row["b"]

                if base_socket:
                    base_socket.default_value[0] = raw_r / 255.0
                    base_socket.default_value[1] = raw_g / 255.0
                    base_socket.default_value[2] = raw_b / 255.0
                    base_socket.keyframe_insert("default_value", frame=frame, index=0)
                    base_socket.keyframe_insert("default_value", frame=frame, index=1)
                    base_socket.keyframe_insert("default_value", frame=frame, index=2)
                else:
                    prop_r, prop_g, prop_b = (
                        (raw_r/255.0, raw_g/255.0, raw_b/255.0)
                        if normalize
                        else (raw_r, raw_g, raw_b)
                    )
                    obj[f'vc[{i}]_R'] = float(prop_r)
                    obj[f'vc[{i}]_G'] = float(prop_g)
                    obj[f'vc[{i}]_B'] = float(prop_b)
                    obj.keyframe_insert(f'["vc[{i}]_R"]', frame=frame)
                    obj.keyframe_insert(f'["vc[{i}]_G"]', frame=frame)
                    obj.keyframe_insert(f'["vc[{i}]_B"]', frame=frame)

        # Register/update frame handler
        handler = make_frame_handler(obj)
        register_handler(handler)

        self.report({"INFO"}, f"セットアップ完了: {len(tracks)} CSV -> {obj.name}（頂点）")
        return {"FINISHED"}

class CSVVA_OT_RemoveHandler(Operator):
    bl_idname = "csvva.remove_handler"
    bl_label = "位置更新ハンドラ解除"
    bl_options = {"REGISTER", "UNDO"}

    def execute(self, context):
        unregister_handler()
        self.report({"INFO"}, "フレーム変更ハンドラを解除しました")
        return {"FINISHED"}


class CSVVA_OT_TransferColorKeys(Operator):
    bl_idname = "csvva.transfer_color_keys"
    bl_label = "カラーキーを移植"
    bl_options = {"REGISTER", "UNDO"}

    def execute(self, context):
        obj = context.active_object
        if not obj or "csv_tracks_json" not in obj:
            self.report({"ERROR"}, "CSVがセットアップされたオブジェクトを選択してください")
            return {"CANCELLED"}

        try:
            payload = json.loads(obj["csv_tracks_json"])
        except Exception:
            self.report({"ERROR"}, "CSV情報を解析できません")
            return {"CANCELLED"}

        tracks = payload.get("tracks", [])
        fps = float(payload.get("fps", 24.0))
        start_frame = int(payload.get("start_frame", 0))

        for tr in tracks:
            base_socket = None
            drones_col = bpy.data.collections.get("Drones")
            if drones_col:
                drone = drones_col.objects.get(tr["name"])
                if drone and drone.active_material and drone.active_material.node_tree:
                    for node in drone.active_material.node_tree.nodes:
                        if node.inputs and node.inputs[0].type == 'RGBA':
                            base_socket = node.inputs[0]
                            break
            if not base_socket:
                continue

            for row in tr["data"]:
                frame = start_frame + ms_to_frame(row["t_ms"], fps)
                base_socket.default_value[0] = row["r"] / 255.0
                base_socket.default_value[1] = row["g"] / 255.0
                base_socket.default_value[2] = row["b"] / 255.0
                base_socket.keyframe_insert("default_value", frame=frame, index=0)
                base_socket.keyframe_insert("default_value", frame=frame, index=1)
                base_socket.keyframe_insert("default_value", frame=frame, index=2)

        # Remove vc[] custom property keyframes and properties
        if obj.animation_data and obj.animation_data.action:
            action = obj.animation_data.action
            for fc in list(action.fcurves):
                if fc.data_path.startswith('["vc['):
                    action.fcurves.remove(fc)
            if not action.fcurves:
                obj.animation_data.action = None
                bpy.data.actions.remove(action)

        for key in list(obj.keys()):
            if key.startswith("vc["):
                del obj[key]

        self.report({"INFO"}, "マテリアルにカラーキーを移植し、vcキーを削除しました")
        return {"FINISHED"}

class CSVVA_PT_UI(Panel):
    bl_label = "CSV Vertex Anim"
    bl_idname = "CSVVA_PT_UI"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "CSV Vertex Anim"

    def draw(self, context):
        lay = self.layout
        prefs = context.scene.csvva_props
        col = lay.column(align=True)
        col.prop(prefs, "folder")
        row = col.row(align=True)
        row.prop(prefs, "fps")
        row.prop(prefs, "start_frame")
        row.prop(prefs, "delimiter")
        col.prop(prefs, "normalize_rgb")
        col.operator(CSVVA_OT_Import.bl_idname, icon="IMPORT")
        col.operator(CSVVA_OT_TransferColorKeys.bl_idname, icon="NODETREE")
        col.separator()
        col.operator(CSVVA_OT_RemoveHandler.bl_idname, icon="X")
